# 国科面试题

## CSS 基础

### 你对 Flex 布局熟悉吗？说说你使用过的属性及其用途？

```css
.box {
  display: flex;
  /* flex-wrap属性定义，如果一条轴线排不下，如何换行。 */
  flex-wrap: nowrap | wrap | wrap-reverse;
  /* flex-direction属性决定主轴的方向（即项目的排列方向）。 */
  flex-direction: row | row-reverse | column | column-reverse;
  /* align-items属性定义项目在交叉轴上如何对齐。 */
  align-items: flex-start | flex-end | center | baseline | stretch;
  /* align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 */
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;

  /* align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 */
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

### 你对 Grid 布局熟悉吗？说说你使用过的属性及其用途？

#### grid-template-columns 属性，grid-template-rows 属性

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;
}
```

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;

  /* grid-template-columns: 33.33% 33.33% 33.33%; */

  /* grid-template-columns: 150px 1fr 2fr; */

  /* grid-template-columns: 1fr 1fr minmax(100px, 1fr); */

  /* grid-template-columns: 100px auto 100px; */
}
```

#### repeat()

```css
.container {
  display: grid;
  grid-template-columns: repeat(3, 33.33%);
  grid-template-rows: repeat(3, 33.33%);

  /* grid-template-columns: repeat(2, 100px 20px 80px); */

  /* grid-template-columns: repeat(auto-fill, 100px); */
}
```

### 水平垂直居中的多种方法

- 绝对定位+负边距
- 绝对定位+transform
- flex 布局
- grid 布局
- table 布局
  - display:table-cell
  - display:inline-block
  - display:inline-block+vertical-align:middle

```css
/* flex */
.box{
  display:flex
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
}
/* grid */
.box{
  display: grid;
  justify-content: center; /* 水平居中 */
  align-items: center; /* 垂直居中 */
}
/* grid2 */
.box{
  place-content: center;
}
/* table布局 */
.box{
  display: table-cell;
  vertical-align: middle;
  text-align: center;
}
```

## Javascript 基础

### 1. 什么是闭包（closure），为什么要用它？(高频)

闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

```js
function foo() {
  var a = 2
  function bar() {
    console.log(a)
  }
  return bar
}
var baz = foo()

baz() // 2
```

闭包的用途：

- 读取函数内部的变量
- 让这些变量的值始终保持在内存中

### 讲讲 cookie ，sessionStorage 和 localStorage 的区别？

- cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。
- 存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。
- 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
- 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。
- Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。

### 讲下什么是事件冒泡，事件捕获？它们有什么区别？

事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。

事件捕获：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。

事件捕获的用意在于在事件到达预定目标之前捕获它。

### 如何取消事件冒泡、事件捕获、默认事件行为。

- 阻止事件冒泡：event.stopPropagation()
- 阻止事件捕获：event.stopImmediatePropagation()、event.cancelBubble = true
- 阻止默认事件行为：event.preventDefault()

### 什么是事件代理？什么是事件委托？

事件代理：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

事件委托：把某些需要频繁触发的事件委托给父元素，通过事件冒泡，减少事件绑定的次数。

### 深拷贝和浅拷贝的区别？

- 浅拷贝：只拷贝一层对象，如果对象中还有对象，那么拷贝的就是对象的引用。
- 深拷贝：拷贝对象中的所有层级，拷贝的是对象的值。

#### 深拷贝的实现思路

- JSON.parse(JSON.stringify(obj))：缺点是无法拷贝函数，会忽略 undefined，无法拷贝正则，无法拷贝日期，无法拷贝对象的循环引用，拷贝对象的时候会丢弃对象的 constructor，拷贝对象的时候会把对象的 **proto** 丢弃，拷贝对象的时候会把对象的 Symbol 属性丢弃。
- 递归拷贝：缺点是无法拷贝函数，会忽略 undefined，无法拷贝正则，无法拷贝日期，无法拷贝对象的循环引用，拷贝对象的时候会丢弃对象的 constructor，拷贝对象的时候会把对象的 **proto** 丢弃，拷贝对象的时候会把对象的 Symbol 属性丢弃。

<!-- TODO -->

### ES6 你用过哪些新特性？

- let 和 const
- 解构赋值
- 箭头函数
- 模板字符串
- Promise
- async/await
- class
- import/export
- Set/Map
- Proxy
- Reflect

讲讲去重的方法

## Vue

### 在 defineProps 中，如何定义类型？

第一种方式：

```js
const props = defineProps({
  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
  propA: Number,
  // 多个可能的类型
  propB: [String, Number],
  // 必填的字符串
  propC: {
    type: String,
    required: true,
  },
  // 带有默认值的数字
  propD: {
    type: Number,
    default: 100,
  },
  // 带有默认值的对象
  propE: {
    type: Object,
    // 对象或数组且一定要从一个工厂函数返回默认值
    default: function () {
      return { message: 'hello' }
    },
  },
  // 自定义验证函数
  propF: {
    validator: function (value) {
      // 这个值必须匹配下列字符串中的一个
      return ['success', 'warning', 'danger'].indexOf(value) !== -1
    },
  },
})
```

第二种方式：

```ts
interface Props {
  propA: number
  propB: string | number
  propC: string
  propD: number
  propE: {
    message: string
  }
  propF: 'success' | 'warning' | 'danger'
}

const props = defineProps<Props>()
```

定义默认值：

```ts
const props = withDefaults(defineProps<PaginationParams>(), {
  page: 1,
  limit: 10,
  total: 0,
  background: true,
  layout: 'total, sizes, prev, pager, next, jumper',
  pageSizes: () => [10, 20, 30, 50, 100],
  onChange: () => {},
})
```

### 讲讲你能想到的 vue2/3 所有区别? vue3 如何做劫持的？

- vue3.0 采用了 Composition API，更加灵活
- vue3.0 采用了 Proxy 代替了 Object.defineProperty，性能更好

vue3 中的响应式原理是通过 Proxy 实现的，Proxy 可以监听到引用类型的变化，而 Object.defineProperty 只能监听到基本类型的变化。

### vue3 中的路由拦截器是怎么实现的？

vue-router 4.0 中的路由拦截器是通过 router.beforeEach 实现的，它是一个全局前置守卫，可以在跳转之前执行一些操作。

- beforeEach
- beforeResolve
- afterEach

### Vue3 中组件通信的方式有哪些？

- props
- $emit/$on
- provide/inject
- $attrs/$listeners
- vuex
- eventBus
- ref
- $parent/$children
- $root
- $refs

### 讲讲 nextTick

可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。

### Vue history 模式的路由和 hash 模式的路由有什么区别？

- hash 模式下，url 中有 #，而 history 模式下没有
- hash 模式下，url 中的 # 后面的内容会被浏览器忽略，不会发送到服务器，而 history 模式下，url 中的内容会被发送到服务器
- hash 模式下，url 中的 # 后面的内容会被浏览器当做锚点，浏览器会自动滚动到对应的锚点位置，而 history 模式下，url 中的内容不会被当做锚点，浏览器不会自动滚动到对应的位置

history 模式的路由，需要后端配合，如果后端没有配置，会出现 404 的情况。

配置 Nginx：

Nginx 配置

```sh
  server {
    location / {
      # =====
      try_files $uri $uri/ /index.html;
    }
  }
```

## 微前端

### 你了解微前端吗？它有什么优缺点？

微前端是一种架构模式，它将一个大型单体应用拆分成多个小型前端应用，每个应用都是一个独立的微服务，可以独立开发、独立部署。

优点：

- 独立开发、独立部署
- 技术栈自由
- 业务解耦,单一职责
- 局部/增量升级

缺点：

- 通信成本
- 重复依赖

### 你了解微前端的实现原理吗？

微前端的实现原理是通过 iframe 嵌套实现的，每个子应用都是一个 iframe，主应用通过 window.postMessage 通信。

### qiankun 是什么？

qiankun 是一个微前端框架，它是基于 single-spa 的二次封装。

#### 它是怎么匹配应用的？

qiankun 会根据应用的注册信息，将应用的路由信息转换成正则表达式，然后通过正则表达式匹配当前的路由。

#### 它是怎么实现应用间的通信的？

qiankun 内部提供了 initGlobalState 方法用于注册 MicroAppStateActions 实例用于通信，该实例有三个方法，分别是：

- setGlobalState：设置 globalState - 设置新的值时，内部将执行 浅检查，如果检查到 globalState 发生改变则触发通知，通知到所有的 观察者 函数。
- onGlobalStateChange：注册 观察者 函数 - 响应 globalState 变化，在
- globalState 发生改变时触发该 观察者 函数。
- offGlobalStateChange：取消 观察者 函数 - 该实例不再响应 globalState 变化。

#### 它是怎么实现应用间的路由跳转的？

qiankun 通过 window.location.href 实现应用间的路由跳转。

#### 它是怎么实现应用间的数据共享的？

#### 它是怎么实现应用间的样式隔离的？

#### 它是怎么实现应用间的生命周期的？

## SSR 服务端渲染

### 你了解 SSR 吗？它有什么优缺点？

SSR 是指服务端渲染，它是将页面在服务端渲染好，然后返回给客户端，客户端直接渲染页面。

优点：

- SEO
- 首屏渲染速度快

缺点：

- 服务端压力大

### 在服务端渲染的代码中，如果直接使用 document 会报错，你知道为什么吗？怎么解决？

因为 document 是浏览器的全局变量，服务端没有 document。 解决方法是可以通过 process.client 判断，或者使用 client-only 组件。

### Git 相关

### 当前的项目中部分文件更改了（可能对方也改了这部分文件），现在你需要更新代码，你会怎么做？

- git fetch
- git merge

- git cherry-pick <commitID> // 拉取某个 commit

- git stash // 临时保存代码
- git stash pop // 恢复代码, 会删除 stash
- git stash apply // 恢复代码, 不会删除 stash
- git stash list // 查看 stash 列表

- git reset --hard <commitID> // 回退到某个版本, 会丢失代码
- git reset --soft <commitID> // 保留代码，回退到某个版本
- git reset --soft HEAD^ // 回退到上一个版本

- git rebase -i HEAD~3 // 合并最近的三个 commit
- git rebase -i <commitID> // 合并某个 commit 之后的 commit

### 你知道 git rebase 吗？它有什么用？

### 当你开发过程中 commit 后，没有 push，这个时候回退了版本，但是你又想回到最新的版本，你会怎么做？

## 性能优化方面

### 1. 你有哪些性能优化的方法？

- 减少 HTTP 请求
- 减少 DOM 操作
- 使用 CSS 雪碧图
- 使用 CSS 合并

以上也可以更换协议为 HTTP2 来优化

- 使用 CSS 预处理器
- 减少 DOM 元素的数量
- 减少 DOM 元素的层级
- 减少 DOM 元素的样式计算
- 减少 DOM 元素的回流和重绘
- 事件的防抖节流
-

- 使用 CSS 压缩
- 使用 JS 压缩
- 使用 JS 模板
- 使用 JS 缓存
- 使用图片懒加载
- 使用图片预加载
- 使用图片压缩
- 使用 CDN
- 使用 Gzip
- 使用浏览器缓存（强缓存，协商缓存，说一下）

- 搭建性能监控系统-使用社区现有的性能监控库实现，或者使用 1px 的图片来实现
- 搭建错误上报系统-类似接入 Sentry

## 其他问题

### 聊聊你对前端工程化的理解？

前端工程化是指将前端开发过程中的一些重复性、规范化的工作自动化，提高前端开发效率和代码质量的一种手段。

做过什么前端工程化的事情？

- 使用过 webpack 吗？说说。
- 使用过 rollup 吗？说说。
- 使用过 vite 吗？说说。
- 使用过 babel 吗？说说。
- 使用过 eslint 吗？说说。
- 对 npm， yarn，pnpm 熟悉吗？说说他们的区别。
- 使用过 husky 吗？说说。
- 使用过 lint-staged 吗？说说。
- 使用过 commitizen 吗？说说。
- 使用过 commitlint 吗？说说。
- 搭建脚手架
- 构建命令行工具
- 使用过 CI/CD 吗？说说。
- 使用过 Docker 吗？说说。

前端工程化的目的是为了提高前端开发效率，降低前端开发成本，提高前端开发质量。

### 大概讲讲你在项目中遇到的一些问题，以及你是如何解决的？

### 你有哪些比较有亮点的技术?

### 你有什么想问我的吗？
