<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>christmasç¬”è¯•ï¼ŒåŸç”Ÿå®ç°</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        background-color: #982c2b;
        display: grid;
        place-content: center;
        height: 100vh;
        width: 100vw;
        /* border: #a0a0a0; */
      }
      .main {
        background-color: white;
        border-radius: 15px;
        padding: 20px;
        width: 500px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="main">
      <canvas id="output" width="500px" height="100px">
        <!-- ä¸å…¼å®¹ canvas çš„æ—¶å€™æ˜¾ç¤ºä¸‹æ–‡ -->
        å½“å‰æµè§ˆå™¨ä¸æ”¯æŒcanvaså…ƒç´ ï¼Œè¯·å‡çº§æˆ–æ›´æ¢æµè§ˆå™¨ï¼
      </canvas>
    </div>

    <!-- christmasç¬”è¯•ï¼Œè¿™é‡Œæˆ‘é€šè¿‡ canvas ç”»å¸ƒåŸç”Ÿå®ç° -->
    <script>
      const canvas = document.getElementById('output');
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      // å®¶æ—åœ£è¯å€¼é˜¶æ¢¯
      const familyChristmasValueStage = [0, 1000000, 2000000, 3600000, 5000000];
      // å®¶æ—åœ£è¯å€¼é˜¶æ¢¯å¯¹åº”çš„åœ£è¯æ ‘ä½ç½®
      let stagePositions = [];
      // å®¶æ—å½“å‰åœ£è¯å€¼
      let currentValue = 0;
      // è·ç¦»ä¸‹ä¸€é˜¶æ®µè¿˜å·®å¤šå°‘åœ£è¯å€¼
      let nextStageValue = 1000000;

      // // åˆå§‹ç”»å¸ƒ
      // function init(initValue) {
      //   // ç»˜åˆ¶å¤´éƒ¨è¯´æ˜æ–‡æœ¬
      //   ctx.font = '16px Arial';
      //   ctx.fillStyle = '#458a5b';
      //   ctx.textAlign = 'left';
      //   ctx.textBaseline = 'middle';
      //   // ç»˜åˆ¶å¤´éƒ¨è¯´æ˜æ–‡æœ¬
      //   const headerText = `å®¶æ—åœ£è¯å€¼ï¼š${currentValue}  ${nextStageValue === 'å·²æ»¡' ? 'ï¼ˆå®¶æ—åœ£è¯å€¼å·²æ»¡ğŸŒ¸ï¼‰' : `ï¼ˆè·ç¦»ä¸‹ä¸€é˜¶æ®µè¿˜å·®${nextStageValue}åœ£è¯å€¼ï¼‰`}`;
      //   ctx.fillText(headerText, 0, 10);
      //   // ç»˜åˆ¶åœ£è¯å€¼åœ†è§’è¿›åº¦æ¡
      //   ctx.fillStyle = '#ccc';
      //   ctx.fillRect(0, 40, width, 15);
      //   ctx.fill();
      //   // ç»˜åˆ¶åœ£è¯å€¼æ¯ä¸ªé˜¶æ®µçš„åˆ»åº¦
      //   drawStage(ctx);
      //   // ç»˜åˆ¶å½“å‰åœ£è¯å€¼è¿›åº¦æ¡;
      //   drawProgress(ctx, initValue || currentValue);
      // }
      // init();

      // // ç»˜åˆ¶åœ£è¯å€¼æ¯ä¸ªé˜¶æ®µçš„åˆ»åº¦
      // function drawStage(ctx) {
      //   ctx.clearRect(0, 60, width, 100);
      //   stagePositions = [];
      //   familyChristmasValueStage.forEach((item, index) => {
      //     // è®¡ç®—æ¯ä¸ªé˜¶æ®µçš„å®½åº¦
      //     const stageWidth = (width / familyChristmasValueStage[familyChristmasValueStage.length - 1]) * familyChristmasValueStage[index];
      //     // ç¬¬ä¸€ä¸ªé˜¶æ®µä¸ç»˜åˆ¶åˆ»åº¦
      //     if (index === 0) return;
      //     const isLastOne = index === familyChristmasValueStage.length - 1;
      //     // ç»˜åˆ¶åˆ»åº¦ï¼ˆåœ£è¯æ ‘ï¼‰
      //     ctx.fillStyle = item > currentValue ? '#a0a0a0' : '#458a5b';
      //     drawTree(ctx, stageWidth - 20, 60, 20, 25);
      //     stagePositions.push(stageWidth);
      //     // ç»˜åˆ¶åˆ»åº¦ï¼ˆåˆ»åº¦å€¼ï¼‰
      //     ctx.fillStyle = item > currentValue ? '#a0a0a0' : '#458a5b';
      //     ctx.textAlign = isLastOne ? 'right' : 'center';
      //     ctx.fillText(`${item / 10000}W`, stageWidth - (isLastOne ? 0 : 10), 80);
      //   });
      // }

      // // ç»˜åˆ¶åœ£è¯æ ‘
      // function drawTree(ctx, x, y, w, h) {
      //   ctx.beginPath();
      //   ctx.moveTo(x, y);
      //   ctx.lineTo(x + w / 2, y - h);
      //   ctx.lineTo(x + w, y);
      //   ctx.lineTo(x, y);
      //   ctx.closePath();
      //   ctx.fill();
      // }

      // // ç»˜åˆ¶å½“å‰åœ£è¯å€¼è¿›åº¦æ¡
      // function drawProgress(ctx, currentValue) {
      //   let progress = 0;
      //   const timer = setInterval(() => {
      //     progress += 5;
      //     ctx.fillStyle = '#fbe67a';
      //     ctx.fillRect(0, 40, progress, 15);
      //     drawStage(ctx);
      //     if (progress >= currentValue / 10000) {
      //       clearInterval(timer);
      //     }
      //   }, 10);
      // }

      // // é‡æ–°ç»˜åˆ¶æ–‡æœ¬å’Œè¿›åº¦æ¡
      // function reDraw(progress) {
      //   ctx.clearRect(0, 0, width, height);
      //   init(progress);
      // }
      // // ç›‘å¬ canvas æ¯ä¸ªé˜¶æ®µçš„ç‚¹å‡»äº‹ä»¶
      // canvas.addEventListener('click', (e) => {
      //   const x = e.offsetX;
      //   const y = e.offsetY;
      //   // åˆ¤æ–­ç‚¹å‡»çš„ä½ç½®æ˜¯å¦åœ¨åœ£è¯æ ‘ä¸Š
      //   if (y < 40 || y > 85) return;
      //   // åˆ¤æ–­ç‚¹å‡»çš„ä½ç½®æ˜¯å“ªä¸ªåœ£è¯æ ‘
      //   // ç‚¹å‡»çš„æ˜¯ä¸­é—´çš„é˜¶æ®µï¼Œé‡æ–°ç»˜åˆ¶è¿›åº¦æ¡
      //   stagePositions.forEach((item, index) => {
      //     if (x < item && x > item - 20) {
      //       currentValue = item * 10000;
      //       nextStageValue = familyChristmasValueStage[index + 2] - currentValue || 'å·²æ»¡';
      //       reDraw(currentValue);
      //     }
      //   });
      // });

      // Checking whether straight lines with empty length have proper line caps
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.moveTo(200, 50);
      ctx.lineTo(220, 50);
      ctx.stroke();
      ctx.closePath();

      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(50, 50);
      ctx.lineTo(50, 50);
      ctx.stroke();
      ctx.lineCap = 'square';
      ctx.beginPath();
      ctx.moveTo(100, 50);
      ctx.lineTo(100, 50);
      ctx.stroke();

      // ç”»ä¸€æ¡ LineCap ä¸º roundï¼ŒåŒ…å«çº¿å¸½æ€»é•¿åº¦ä¸º 10 çš„çº¿æ®µ
      
    </script>
  </body>
</html>
